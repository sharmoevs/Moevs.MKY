//angle_reductosin.c
#include "angle_reductosin.h"

#ifdef REDUCTOSIN_16
#define K0 4
#endif
#ifdef REDUCTOSIN_32
#define K0 5
#endif
#ifdef REDUCTOSIN_64
#define K0 6
#endif
#ifndef K0
#error "Reductosine is not specified! (Define one of the parameters: REDUCTOSIN_16, REDUCTOSIN_32 or REDUCTOSIN_64)"
#endif
#define MASK_H (0xFFFFFFFF<<(32-K0))            // маска для выделения старших значащих бит
#define MASK_L (~MASK_H)                        // маска для выделения младших значещих бит, она же период точного датчика!
#define K1 (16-K0)

u32 angle_Reductosin(u16 roughAngle, u16 precisionAngle)
{
	u32 X;
	//Перевести грубый угол в единую систему кодирования с точным углом
	u32 A0I = (roughAngle<<K0)/3;
	//Найти размер остатка от целого количества точных секторов поместившихся в неточном секторе
	u16 A0II = A0I % 0x10000;		 
	//Определить разницу между остатком в неточном секторе и текущим точным углом
	u16 A01 =  precisionAngle - A0II;	 
	//По величене разницы определить в каком из трёх неточных секторов оказался текущий угол
	if((A01>0xD555)||(A01<0x2AAA)) X = 0; // сектор от 0° до 120°
	else if(A01<0x8000) X = 0x55555555;   // сектор от 120° до 240°
	else X = 0xAAAAAAAA;                  // сектор от 240° до 360°
	
	u32 R = X + A0I<<K1;         	//текущий угол в виде 32битного значения, вычисленный только с помощью неточного угла
	u32 R_h = R&MASK_H;						//старшая часть этого угла, которая не может быть определена с помощью точного угла
	u32 R_l = R&MASK_L;       		//младшая часть этого угла, которая может быть определена с помощью точного угла
	u32 A1 = precisionAngle<<K1;  //приведение точного угла в соответствие с 32битной системой кодирования угла
	
	//При необходимости внести коррекции, которые могут понадобиться из-за неточного геометрического
	//расположения обмоток точного и неточного угла в редуктосине относительно друг друга
	//(точный угол чуть обгоняет неточный угол или наоборот)
	if(R_l<(MASK_L/3))
	{//Первый подсектор
		if(A1>(2*MASK_L/3)) R_h -= 1<<(16+K1);
	}
	else if(R_l>(2*MASK_L/3))
	{//Третий подсектор
		if(A1<(MASK_L/3)) R_h += 1<<(16+K1);
	}
	
	//32-битный результат точного определения угла
	return R_h+A1;
}

